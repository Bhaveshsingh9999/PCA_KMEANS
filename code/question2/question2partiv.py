# -*- coding: utf-8 -*-
"""question2partiv.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/158jYbtAFbwGcexnhlSHcyQErqSVl2Cxp
"""

from google.colab import files
uploaded = files.upload()
import pandas as pd

import numpy as np
import random
from numpy.linalg import eig
import matplotlib.pyplot as plt
import math
col=['F1','F2']
data = pd.read_csv("Dataset.csv",names=col)
numm=data.to_numpy()

def transpose(matrixa):
  matrixb=np.zeros((2,1000))
  for i in range(2):
    for j in range(1000):
      matrixb[i][j]=matrixa[j][i]
  return matrixb

def centering(matrixk):
  i=np.identity(1000)
  x=np.ones((1000,1000))/1000
  t=i-x
  kc=np.matmul(t,matrixk)
  kc=np.matmul(kc,t)
  return kc

def normalize(eigenmatrix):
  z=[]
  for i in range(1000):
    t=np.argmax(eigenmatrix[i])
    z.append(t)

  #print(z)
    
  return z

def poly_kernelmatrix(matrixa,degree):
  k=np.zeros((1000,1000))
  matrixb=transpose(np.copy(matrixa))
  for i in range (1000):
    for j in range(1000):
      for l in range (2):
        k[i][j]+=matrixa[i][l]*matrixb[l][j]
      k[i][j]+=1
      k[i][j]=k[i][j]**degree

  return k

def radial_kernelmatrix(matrixa,sigma):
  k=np.zeros((1000,1000))
  temp=np.zeros((2,2))
  for i in range (1000):
    for j in range(1000):
      temp=matrixa[i]-matrixa[j]
      k[i][j]=np.dot(temp,temp)
      k[i][j]=k[i][j]/(2*(sigma**2))
      k[i][j]=math.exp(k[i][j]*-1)

  return k

def Hmatrixpoly(numm,degree):
  kmatrix=poly_kernelmatrix(np.copy(numm),degree)
  kmatrix=centering(np.copy(kmatrix))
  eigenvalues,eigenvectors=eig(kmatrix)
  idx=eigenvalues.argsort()[::-1]
  eigenvalues=eigenvalues[idx]
  eigenvectors=eigenvectors[:,idx]
  hmat=eigenvectors[:,:4]
  return hmat

def Hmatrixradial(numm,sigma):
  kmatrix=radial_kernelmatrix(np.copy(numm),sigma)
  kmatrix=centering(np.copy(kmatrix))
  eigenvalues,eigenvectors=eig(kmatrix)
  idx=eigenvalues.argsort()[::-1]
  eigenvalues=eigenvalues[idx]
  eigenvectors=eigenvectors[:,idx]
  hmat=eigenvectors[:,:4]
  return hmat

def plot_kmeans(numm):

  final=pd.DataFrame(numm,columns=['F1','F2','Z'])
  plt.scatter( final['F1'][(final.Z == 1)],final['F2'][(final.Z == 1)],marker='o',color='red',label='cluster1')
  plt.scatter( final['F1'][(final.Z == 2)],final['F2'][(final.Z == 2)],marker='o',color='blue',label='cluster2')
  plt.scatter( final['F1'][(final.Z == 3)],final['F2'][(final.Z == 3)],marker='o',color='indigo',label='cluster3')
  plt.scatter( final['F1'][(final.Z == 0)],final['F2'][(final.Z == 0)],marker='o',color='black',label='cluster4')
  plt.xlabel('feature 1')
  plt.ylabel('feature 2')
  plt.legend(bbox_to_anchor = (1.05, 0.6))

def spectralkmeanpoly(degree):
  col=['F1','F2']
  data = pd.read_csv("Dataset.csv",names=col)
  numm=data.to_numpy()
  hmat=Hmatrixpoly(np.copy(numm),degree)
  z=normalize(np.copy(hmat))
  data['Z']=z
  numm=data.to_numpy()
  plot_kmeans(np.copy(numm))

def spectralkmeanradial(sigma):
  col=['F1','F2']
  data = pd.read_csv("Dataset.csv",names=col)
  numm=data.to_numpy()
  hmat=Hmatrixradial(np.copy(numm),sigma)
  z=normalize(np.copy(hmat))
  data['Z']=z
  numm=data.to_numpy()
  plot_kmeans(np.copy(numm))

spectralkmeanpoly(2)

spectralkmeanpoly(3)

spectralkmeanradial(0.1)

spectralkmeanradial(0.2)

spectralkmeanradial(0.3)

spectralkmeanradial(0.4)

spectralkmeanradial(0.5)

spectralkmeanradial(0.6)

spectralkmeanradial(0.7)

spectralkmeanradial(0.8)

spectralkmeanradial(0.9)

spectralkmeanradial(1)