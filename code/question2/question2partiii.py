# -*- coding: utf-8 -*-
"""question2partiii.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1chnNzmTF9bBrvzgoAtZhmt6RI__P6AVm
"""

from google.colab import files
uploaded = files.upload()
import pandas as pd

import numpy as np
import random
from numpy.linalg import eig
import matplotlib.pyplot as plt
import math
col=['F1','F2']
data = pd.read_csv("Dataset.csv",names=col)
numm=data.to_numpy()

def transpose(matrixa):
  matrixb=np.zeros((2,1000))
  for i in range(2):
    for j in range(1000):
      matrixb[i][j]=matrixa[j][i]
  return matrixb

def poly_kernelmatrix(matrixa,degree):
  k=np.zeros((1000,1000))
  matrixb=transpose(np.copy(matrixa))
  for i in range (1000):
    for j in range(1000):
      for l in range (2):
        k[i][j]+=matrixa[i][l]*matrixb[l][j]
      k[i][j]+=1
      k[i][j]=k[i][j]**degree

  return k

def radial_kernelmatrix(matrixa,sigma):
  k=np.zeros((1000,1000))
  temp=np.zeros((2,2))
  for i in range (1000):
    for j in range(1000):
      temp=matrixa[i]-matrixa[j]
      k[i][j]=np.dot(temp,temp)
      k[i][j]=k[i][j]/(2*(sigma**2))
      k[i][j]=math.exp(k[i][j]*-1)

  return k

def centering(matrixk):
  i=np.identity(1000)
  x=np.ones((1000,1000))/1000
  t=i-x
  kc=np.matmul(t,matrixk)
  kc=np.matmul(kc,t)
  return kc

def normalize(eigenmatrix):
  for i in range(4):
    t=np.linalg.norm(eigenmatrix[:,i])
    eigenmatrix[:,i]=eigenmatrix[:,i]/t
  for i in range(1000):
    t=np.linalg.norm(eigenmatrix[i])
    eigenmatrix[i]=eigenmatrix[i]/t
  
  return eigenmatrix

def Hmatrixpoly(numm,degree):
  kmatrix=poly_kernelmatrix(np.copy(numm),degree)
  kmatrix=centering(np.copy(kmatrix))
  eigenvalues,eigenvectors=eig(kmatrix)
  idx=eigenvalues.argsort()[::-1]
  eigenvalues=eigenvalues[idx]
  eigenvectors=eigenvectors[:,idx]
  hmat=eigenvectors[:,:4]
  hmat=normalize(np.copy(hmat))
  return hmat

def Hmatrixradial(numm,sigma):
  kmatrix=radial_kernelmatrix(np.copy(numm),sigma)
  kmatrix=centering(np.copy(kmatrix))
  eigenvalues,eigenvectors=eig(kmatrix)
  idx=eigenvalues.argsort()[::-1]
  eigenvalues=eigenvalues[idx]
  eigenvectors=eigenvectors[:,idx]
  hmat=eigenvectors[:,:4]
  hmat=normalize(np.copy(hmat))
  return hmat

def random_initialization():
  z=[]
  
  for i in range(1000):
    z.append(random.randint(0,3))
  return z

def Pointscount(z):
  count={}
  for i in z:
    if i in count:
      count[i]=count[i]+1
    else:
      count[i]=1
  return count

def k_means(numm):
 
  while(True):
    # mean calculation 
    currentmean={}
    for i in  range(1000):
      xi=np.copy(numm[i,:4])
      if numm[i][4] in currentmean:
        currentmean[numm[i][4]]=currentmean[numm[i][4]]+xi
      else:
        currentmean[numm[i][4]]=xi
    count=Pointscount(numm[:,4])
    for i in count:
      if(count[i]!=0):
        currentmean[i]=currentmean[i]/count[i]
    
    flag=0

    # reinitialization 
    error=0

    for i in range(1000):
      xi=np.copy(numm[i,:4])
      k=arg=numm[i][4]
      dist = (np.linalg.norm(xi- currentmean[arg]))**2
      for j in currentmean:
        val = (np.linalg.norm(xi-currentmean[j]))**2
        if(val<dist):
          k=j
          dist=val
      if(k!=arg):
        flag=1
        numm[i][4]=k
    #print(error)
    count=Pointscount(numm[:,4])
    if(flag==0):
      return numm[:,4].tolist()
      break

def plot_kmeans(numm):

  final=pd.DataFrame(numm,columns=['F1','F2','Z'])
  plt.scatter( final['F1'][(final.Z == 1)],final['F2'][(final.Z == 1)],marker='o',color='red',label='cluster1')
  plt.scatter( final['F1'][(final.Z == 2)],final['F2'][(final.Z == 2)],marker='o',color='blue',label='cluster2')
  plt.scatter( final['F1'][(final.Z == 3)],final['F2'][(final.Z == 3)],marker='o',color='indigo',label='cluster3')
  plt.scatter( final['F1'][(final.Z == 0)],final['F2'][(final.Z == 0)],marker='o',color='black',label='cluster4')
  plt.xlabel('feature 1')
  plt.ylabel('fature 2')
  plt.legend(bbox_to_anchor = (1.05, 0.6))

def spectralkmeanpoly(degree):
  col=['F1','F2']
  data = pd.read_csv("Dataset.csv",names=col)
  numm=data.to_numpy()
  hmat=Hmatrixpoly(np.copy(numm),degree)
  hmat=normalize(np.copy(hmat))  
  z=random_initialization()
  z=np.array(z)
  df = pd.DataFrame(hmat, columns = ['A','B','C','D'])
  df['Z']=z
  hmat=df.to_numpy()
  z=k_means(np.copy(hmat))
  data['Z']=z
  numm=data.to_numpy()
  plot_kmeans(np.copy(numm))

def spectralkmeanradial(sigma):
  col=['F1','F2']
  data = pd.read_csv("Dataset.csv",names=col)
  numm=data.to_numpy()
  hmat=Hmatrixradial(np.copy(numm),sigma)
  hmat=normalize(np.copy(hmat))
  #print(hmat)
  z=random_initialization()
  z=np.array(z)
  df = pd.DataFrame(hmat, columns = ['A','B','C','D'])
  df['Z']=z
  hmat=df.to_numpy()
  z=k_means(np.copy(hmat))
  #print(z)
  data['Z']=z
  numm=data.to_numpy()
  plot_kmeans(np.copy(numm))

spectralkmeanpoly(2)

spectralkmeanpoly(3)

spectralkmeanradial(0.1)

spectralkmeanradial(0.2)

spectralkmeanradial(0.3)

spectralkmeanradial(0.4)

spectralkmeanradial(0.5)

spectralkmeanradial(0.6)

spectralkmeanradial(0.7)

spectralkmeanradial(0.8)

spectralkmeanradial(0.9)

spectralkmeanradial(1)